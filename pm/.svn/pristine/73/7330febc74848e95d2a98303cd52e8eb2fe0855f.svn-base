package com.cninsure.payment.communication.weixin.sender;

import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.security.KeyManagementException;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;

import javax.net.ssl.SSLContext;

import net.sf.json.JSONObject;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.http.client.ClientProtocolException;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.conn.ssl.SSLConnectionSocketFactory;
import org.apache.http.conn.ssl.SSLContextBuilder;
import org.apache.http.conn.ssl.TrustStrategy;
import org.apache.http.impl.client.BasicResponseHandler;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;

import com.common.SysParams;

public class GetAccessToken
{

	private static Log log = LogFactory.getLog(GetAccessToken.class);
	private static String accessToken = null;
	private static long expireTime = 0;

	/**
	 * 获取access token
	 * 
	 * @return
	 */
	public static String getAccessToken()
	{
		
		if (log.isDebugEnabled())
			log.debug("\n#####################\n获取accessToken["+accessToken+"],expireTime["+expireTime+"],当前时间["+System.currentTimeMillis()+"]");
		// 判断是否已经存在accessToken
		if (accessToken != null
				&& System.currentTimeMillis() < (expireTime - 300000))
		{// 如果accessToken有值，而且当前时间距离过期时间大于5分钟
			return accessToken;
		}
		else
		{// 重新获取token
			regetToken();
		}
		return accessToken;
	}

	public static void regetToken()
	{
		try
		{
			SSLContext sslContext = new SSLContextBuilder().loadTrustMaterial(
					null, 
					new TrustStrategy() {
						// 信任所有
						public boolean isTrusted(
								X509Certificate[] chain,
								String authType) throws CertificateException
						{

							return true;

						}

					}).build();

			SSLConnectionSocketFactory sslsf = new SSLConnectionSocketFactory(
					sslContext);

			CloseableHttpClient client = HttpClients.custom()
					.setSSLSocketFactory(sslsf).build();
			
			HttpGet get = new HttpGet();
			
			get.setURI(
					new URI(
							SysParams.WEIXIN_URL_TOKEN
							+"?grant_type=client_credential"
							+"&appid="+SysParams.APP_ID
							+"&secret="+SysParams.APP_SECRET
						));
			
			String response=client.execute(get,new BasicResponseHandler());
			
			JSONObject object=JSONObject.fromObject(response);
			accessToken=object.getString("access_token");
			expireTime=System.currentTimeMillis()+object.getInt("expires_in")*1000;

		}
		catch (KeyManagementException e)
		{

			log.error("发送消息到微信服务器失败，无法创建SSL连接",e);

		}
		catch (NoSuchAlgorithmException e)
		{

			log.error("发送消息到微信服务器失败，无法创建SSL连接",e);

		}
		catch (KeyStoreException e)
		{

			log.error("发送消息到微信服务器失败，无法创建SSL连接",e);

		}
		catch (URISyntaxException e)
		{
			// TODO Auto-generated catch block
			log.error("发送消息到微信服务器失败，无法创建SSL连接",e);
		}
		catch (ClientProtocolException e)
		{
			// TODO Auto-generated catch block
			log.error("发送消息到微信服务器失败，无法创建SSL连接",e);
		}
		catch (IOException e)
		{
			// TODO Auto-generated catch block
			log.error("发送消息到微信服务器失败，无法发送消息",e);
		}

	}
	
	public static void main(String[] args)
	{
		GetAccessToken.getAccessToken();
	}
}
